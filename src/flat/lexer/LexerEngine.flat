package flat/lexer

import flat/compiler/models/Lexeme
import flat/compiler/models/Token
import flat/io/File
import flat/log/Logger
import flat/eventstream/EventStream

import flat/extensions/SyntaxStringFunctions

class {
  static Logger log = Logger(LexerEngine.class)

  static var Int externalBlock = 0
  static String EXTERNAL_BLOCK_VALUE = "external"

  checkExternalBlock(String value) {
    if (value == EXTERNAL_BLOCK_VALUE) {
      externalBlock = 1
    } else if (externalBlock == 1 && value == "{") {
      externalBlock = 2
    } else if (externalBlock == 1) {
      return
    } else {
      externalBlock = 0
    }
  }

  public createToken(Lexeme lexeme) -> Token {
    let type = getTypeForLexeme(lexeme)

    checkExternalBlock(lexeme.value)

    return Token(
      value: lexeme.value,
      location: lexeme.location,
      type: type
    )
  }

  getTypeForLexeme(Lexeme lexeme) -> Int {
    if (externalBlock == 2) {
      externalBlock = 0
      return Token.Type.CODE
    } if (lexeme.value == "null") {
      return Token.Type.NULL
    } else if (lexeme.value == "true" || lexeme.value == "false") {
      return Token.Type.BOOL
    } else if (lexeme.value.startsWith("//")) {
      return Token.Type.COMMENT
    } else if (lexeme.value.startsWith("/*")) {
      return Token.Type.COMMENT
    } else if (lexeme.value.isWhitespace()) {
      return Token.Type.WS
    } else if (lexeme.value.isSurroundedByQuotes()) {
      return Token.Type.STRING
    } else if (lexeme.value.isCharLiteral()) {
      return Token.Type.CHAR
    } else if (lexeme.value.isUnsignedInteger()) {
      return Token.Type.INTEGER
    } else if (lexeme.value.isUnsignedFloat()) {
      return Token.Type.FLOAT
    } else if (lexeme.value.isSymbol()) {
      return Token.Type.SYMBOL
    } else {
      return Token.Type.IDENTIFIER
    }
  }
}
