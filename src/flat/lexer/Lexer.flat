package flat/lexer

import flat/io/File
import flat/log/Logger
import flat/stream/Stream

import flat/extensions/SyntaxStringFunctions

class {
  let static Logger log = Logger(Lexer.class)
  let static Char[] STATEMENT_END_CHARS = ['\n', '.', ';', '{', '}', '[', ']', '(', ')', '/', '*', '%', '<', '>', '=', ' ', ':', '!', '+', '-']

  public lex(File file) => lex(file.createReadStream())

  public lex(Stream dataStream) -> Stream {
    let stream = Stream(true)

    dataStream.on<String>("data", (data) => {
      Lexer.log.trace("Received data from Stream with count: #{data.count}")
      let chunkStream = lex(data)

      chunkStream.on<Lexeme>("data", (lexeme) => {
        Lexer.log.trace("Received lexeme from Lexeme Stream: #{lexeme}")
        stream.emit("data", lexeme)$
      })$

      chunkStream.on<String>("error", (error) => {
        Lexer.log.trace("Received error from Lexeme Stream: #{error}")
        stream.emit("error", error)$
      })$

      chunkStream.on("close", {
        Lexer.log.trace("Lexeme Stream closed")
      })$
    })$

    dataStream.on<String>("error", (error) => {
      Lexer.log.trace("Received error from Stream: #{error}")
      stream.emit("error", error)$
    })$

    dataStream.on("close", {
      Lexer.log.trace("Stream closed")
      stream.emit("close")$
    })$

    return stream
  }

  public lex(String contents) -> Stream {
    let stream = Stream(true)

    var Int prevIndex = -1
    var Int index = contents.findCharOnTopLevel(STATEMENT_END_CHARS)

    var Int lineNumber = 1
    var Int column = 1

    while (index != -1) {
      let char = contents[index]

      if ((let skipTo = checkLexemeContinuation(contents, char, index)) != -2) {
        index = skipTo
        continue
      }

      let lexeme = createLexeme(contents, index, prevIndex, lineNumber, column)

      stream.emit("data", lexeme)$

      column += index - prevIndex
      lineNumber += lexeme.value.howMany('\n')

      match char {
        '\n' => {
          lineNumber++
          column = 1
        }
      }

      prevIndex = index
      index = contents.findCharOnTopLevel(STATEMENT_END_CHARS, start: index + 1)
    }

    if (let remainder = createLexeme(contents, index, prevIndex, lineNumber, column)) {
      stream.emit("data", remainder)$
    }

    stream.emit("close")$

    return stream
  }

  checkLexemeContinuation(String contents, Char char, Int index) -> Int => -2 {
    if (index == contents.count - 1) {
      return -2
    }

    switch char {
      '.' => {
        if (contents[index + 1].isNumber) {
          return contents.findCharOnTopLevel(STATEMENT_END_CHARS, start: index + 1)
        }
      }
      '+' => fallthrough
      '-' => fallthrough
      '*' => fallthrough
      '/' => fallthrough
      '&' => fallthrough
      '|' => fallthrough
      '%' => fallthrough
      '^' => fallthrough
      '<' => fallthrough
      '>' => fallthrough
      '!' => fallthrough
      '=' => {
        if (contents[index + 1] == '=') {
          return index == contents.count - 2 ? -1 : index + 2
        }
      }
    }
  }

  createLexeme(
    String contents,
    Int index,
    Int prevIndex,
    Int lineNumber,
    Int column
  ) -> Lexeme => null {
    let value = contents.substring(prevIndex + 1, index == -1 ? contents.count : index)
    let trimmedStart = value.trimStart()
    let trimmed = trimmedStart.trimEnd()
    let buffer = contents.substring(prevIndex, prevIndex + 1 + (value.count - trimmedStart.count))

    if (value.count > 0 || buffer.count > 0) {
      return Lexeme(
        buffer: buffer,
        value: trimmed,
        type: getTypeForValue(value),
        location: Lexeme.Location(
          lineNumber: lineNumber,
          column: column
        )
      )
    }
  }

  getTypeForValue(String value) -> Int {
    if (value.startsWith("//")) {
      return Lexeme.Type.COMMENT
    } else if (value.isSurroundedByQuotes()) {
      return Lexeme.Type.STRING
    } else if (value.isUnsignedInteger()) {
      return Lexeme.Type.INTEGER
    } else if (value.isUnsignedFloat()) {
      return Lexeme.Type.FLOAT
    } else {
      return Lexeme.Type.IDENTIFIER
    }
  }
}
