package flat/lexer

import flat/compiler/models/Lexeme
import flat/compiler/models/Token
import flat/io/File
import flat/log/Logger
import flat/stream/Stream

import flat/extensions/SyntaxStringFunctions

class {
  let static Logger log = Logger(Lexer.class)
  let static Char[] DELIMITERS = ".;{}[]()/*%<>= \t\n\r:!+-\\".chars.toCharArray()

  public lex(File file) => lexemesToTokens(Tokenizer().tokenize(file))
  public lex(Stream dataStream) => lexemesToTokens(Tokenizer().tokenize(dataStream))
  public lex(String contents) => lexemesToTokens(Tokenizer().tokenize(contents))

  public lexemesToTokens(Stream lexemeStream) -> Stream {
    let stream = Stream(true)

    lexemeStream.on<Lexeme>("data", (lexeme) => {
      Lexer.log.trace("Received data from Lexeme Stream: #{lexeme}")
      let token = createToken(lexeme)
      Lexer.log.trace("Created Token from Lexeme: #{token}")

      stream.emit("data", token)$
    })$

    lexemeStream.on<String>("error", (error) => {
      Lexer.log.trace("Received error from Lexeme Stream: #{error}")
      stream.emit("error", error)$
    })$

    lexemeStream.on("close", {
      Lexer.log.trace("Stream closed")
      stream.emit("close")$
    })$

    return stream
  }

  createToken(Lexeme lexeme) -> Token {
    return Token(
      value: lexeme.value,
      location: lexeme.location,
      type: getTypeForLexeme(lexeme)
    )
  }

  getTypeForLexeme(Lexeme lexeme) -> Int {
    if (lexeme.value.startsWith("//")) {
      return Token.Type.COMMENT
    } else if (lexeme.value.startsWith("/*")) {
      return Token.Type.COMMENT
    } else if (lexeme.value.trim().count == 0) {
      return Token.Type.WS
    } else if (lexeme.value.isSurroundedByQuotes()) {
      return Token.Type.STRING
    } else if (lexeme.value.isUnsignedInteger()) {
      return Token.Type.INTEGER
    } else if (lexeme.value.isUnsignedFloat()) {
      return Token.Type.FLOAT
    } else if (lexeme.value.isSymbol()) {
      return Token.Type.SYMBOL
    } else {
      return Token.Type.IDENTIFIER
    }
  }
}
