package flat/lexer

import flat/compiler/models/Lexeme
import flat/compiler/models/Token
import flat/io/File
import flat/log/Logger
import flat/stream/Stream

import flat/extensions/SyntaxStringFunctions

class {
  static Logger log = Logger(Lexer.class)
  static Char[] DELIMITERS = ".;{}[]()/*%<>= \t\n\r:!+-\\".chars.toCharArray()

  public lex(File file) => lexemesToTokens(Tokenizer().tokenize(file))
  public lex(Stream dataStream) => lexemesToTokens(Tokenizer().tokenize(dataStream))
  public lex(String contents) => lexemesToTokens(Tokenizer().tokenize(contents))

  public lexemesToTokens(Stream lexemeStream) -> Stream {
    let stream = Stream(true)

    let engine = LexerEngine()

    let dataEvent = lexemeStream.on<Lexeme>("data", (lexeme) => {
      Lexer.log.traceFunc({"Received data from Lexeme Stream: #{lexeme}"})
      let token = engine.createToken(lexeme)
      Lexer.log.traceFunc({"Created Token from Lexeme: #{token}"})

      stream.emit("data", token)$
    })$

    let errorEvent = lexemeStream.on<String>("error", (error) => {
      Lexer.log.traceFunc({"Received error from Lexeme Stream: #{error}"})
      stream.emit("error", error)$
    })$

    lexemeStream.on("close", {
      await dataEvent
      await errorEvent
      Lexer.log.traceFunc({"Stream closed"})
      stream.emit("close")$
    })$

    return stream
  }
}
