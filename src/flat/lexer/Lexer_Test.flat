package flat/lexer

import flat/lexer/Lexer
import flat/compiler/models/Lexeme

import static flat/lexer/TestUtils_Test.TestUtils

testable class {
  async test `can lex basic package statement with location info`() {
    let value = Lexer().lex("|
      package flat/lexer
      |").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(
        value: "package",
        location: Lexeme.Location(lineNumber: 1, column: 1)
      ),
      Lexeme(
        value: " ",
        location: Lexeme.Location(lineNumber: 1, column: 8)
      ),
      Lexeme(
        value: "flat",
        location: Lexeme.Location(lineNumber: 1, column: 9)
      ),
      Lexeme(
        value: "/",
        location: Lexeme.Location(lineNumber: 1, column: 13)
      ),
      Lexeme(
        value: "lexer",
        location: Lexeme.Location(lineNumber: 1, column: 14)
      )
    ]

    expectLexemes(value, expected, checkLocation: true)
  }

  async test `can lex float`() {
    let value = Lexer().lex("234.141").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(value: "234.141")
    ]

    expectLexemes(value, expected)
  }

  async test `can lex integer`() {
    let value = Lexer().lex("234").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(value: "234")
    ]

    expectLexemes(value, expected)
  }

  async test `can lex String`() {
    let value = Lexer().lex("\"this is a string\"").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(value: "\"this is a string\"")
    ]

    expectLexemes(value, expected)
  }

  async test `can lex greater-than-or-equal-to symbol when its not the last lexeme`() {
    let value = Lexer().lex(">= hey").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(value: ">="),
      Lexeme(value: " "),
      Lexeme(value: "hey")
    ]

    expectLexemes(value, expected)
  }

  async test `can lex greater-than-or-equal-to symbol`() {
    let value = Lexer().lex(">=").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(value: ">=")
    ]

    expectLexemes(value, expected)
  }

  async test `can lex less-than-or-equal-to symbol`() {
    let value = Lexer().lex("<=").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(value: "<=")
    ]

    expectLexemes(value, expected)
  }

  async test `can lex equivalence symbol`() {
    let value = Lexer().lex("==").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(value: "==")
    ]

    expectLexemes(value, expected)
  }

  async test `can lex non-equivalence symbol`() {
    let value = Lexer().lex("!=").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(value: "!=")
    ]

    expectLexemes(value, expected)
  }

  async test `can lex modulo-equals symbol`() {
    let value = Lexer().lex("%=").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(value: "%=")
    ]

    expectLexemes(value, expected)
  }

  async test `can lex divide-equals symbol`() {
    let value = Lexer().lex("/=").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(value: "/=")
    ]

    expectLexemes(value, expected)
  }

  async test `can lex multiply-equals symbol`() {
    let value = Lexer().lex("*=").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(value: "*=")
    ]

    expectLexemes(value, expected)
  }

  async test `can lex plus-equals symbol`() {
    let value = Lexer().lex("+=").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(value: "+=")
    ]

    expectLexemes(value, expected)
  }

  async test `can lex minus-equals symbol`() {
    let value = Lexer().lex("-=").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(value: "-=")
    ]

    expectLexemes(value, expected)
  }

  async test `handles no whitespace between lexemes`() {
    let value = Lexer().lex("this+that").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(value: "this"),
      Lexeme(value: "+"),
      Lexeme(value: "that")
    ]

    expectLexemes(value, expected)
  }

  async test `handles first lexeme as a symbol`() {
    let value = Lexer().lex("+that").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(value: "+"),
      Lexeme(value: "that")
    ]

    expectLexemes(value, expected)
  }

  async test `handles preceding newlines`() {
    let value = Lexer().lex("\n\nthis+that").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(value: "\n\n"),
      Lexeme(value: "this"),
      Lexeme(value: "+"),
      Lexeme(value: "that")
    ]

    expectLexemes(value, expected)
  }

  async test `can lex basic package statement and import statement with location info`() {
    let value = Lexer().lex("|
      package flat/lexer

      import flat/lexer/Lexer
      |").consumeAll<Lexeme>("data")

    let Lexeme[] expected = [
      Lexeme(
        value: "package",
        location: Lexeme.Location(lineNumber: 1, column: 1)
      ),
      Lexeme(
        value: " ",
        location: Lexeme.Location(lineNumber: 1, column: 8)
      ),
      Lexeme(
        value: "flat",
        location: Lexeme.Location(lineNumber: 1, column: 9)
      ),
      Lexeme(
        value: "/",
        location: Lexeme.Location(lineNumber: 1, column: 13)
      ),
      Lexeme(
        value: "lexer",
        location: Lexeme.Location(lineNumber: 1, column: 14)
      ),
      Lexeme(
        value: "\n\n",
        location: Lexeme.Location(lineNumber: 1, column: 19)
      ),
      Lexeme(
        value: "import",
        location: Lexeme.Location(lineNumber: 3, column: 1)
      ),
      Lexeme(
        value: " ",
        location: Lexeme.Location(lineNumber: 3, column: 7)
      ),
      Lexeme(
        value: "flat",
        location: Lexeme.Location(lineNumber: 3, column: 8)
      ),
      Lexeme(
        value: "/",
        location: Lexeme.Location(lineNumber: 3, column: 12)
      ),
      Lexeme(
        value: "lexer",
        location: Lexeme.Location(lineNumber: 3, column: 13)
      ),
      Lexeme(
        value: "/",
        location: Lexeme.Location(lineNumber: 3, column: 18)
      ),
      Lexeme(
        value: "Lexer",
        location: Lexeme.Location(lineNumber: 3, column: 19)
      )
    ]

    expectLexemes(value, expected, checkLocation: true)
  }

  async test `can lex function call`() {
    let value = Lexer().lex("|
      parse(ParseRequest(sourceCode: test), value)
      |").consumeAll<Lexeme>("data")

    let Lexeme[] expected = [
      Lexeme(value: "parse"),
      Lexeme(value: "("),
      Lexeme(value: "ParseRequest"),
      Lexeme(value: "("),
      Lexeme(value: "sourceCode"),
      Lexeme(value: ":"),
      Lexeme(value: " "),
      Lexeme(value: "test"),
      Lexeme(value: ")"),
      Lexeme(value: ","),
      Lexeme(value: " "),
      Lexeme(value: "value"),
      Lexeme(value: ")")
    ]

    expectLexemes(value, expected)
  }
}
