package flat/lexer

import flat/lexer/Lexer

import static flat/lexer/TestUtils_Test.TestUtils

testable class {
  async test `can lex basic package statement with location info`() {
    let value = Lexer().lex("|
      package flat/lexer
      |").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(
        value: "package",
        buffer: "",
        location: Lexeme.Location(
          lineNumber: 1,
          column: 1
        )
      ),
      Lexeme(
        value: "flat",
        buffer: " ",
        location: Lexeme.Location(
          lineNumber: 1,
          column: 9
        )
      ),
      Lexeme(
        value: "lexer",
        buffer: "/",
        location: Lexeme.Location(
          lineNumber: 1,
          column: 14
        )
      )
    ]

    expectLexemes(value, expected, checkLocation: true)
  }

  async test `can lex basic package statement with type info`() {
    let value = Lexer().lex("|
      package flat \"test\"
      |").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(
        value: "package",
        buffer: "",
        type: Lexeme.Type.IDENTIFIER
      ),
      Lexeme(
        value: "flat",
        buffer: " ",
        type: Lexeme.Type.IDENTIFIER
      ),
      Lexeme(
        value: "\"test\"",
        buffer: " ",
        type: Lexeme.Type.STRING
      )
    ]

    expectLexemes(value, expected, checkType: true)
  }

  async test `can lex float`() {
    let value = Lexer().lex("|
      234.141
      |").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(
        value: "234.141",
        buffer: "",
        type: Lexeme.Type.FLOAT
      )
    ]

    expectLexemes(value, expected, checkType: true)
  }

  async test `can lex integer`() {
    let value = Lexer().lex("|
      234
      |").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(
        value: "234",
        buffer: "",
        type: Lexeme.Type.INTEGER
      )
    ]

    expectLexemes(value, expected, checkType: true)
  }

  async test `can lex String`() {
    let value = Lexer().lex("|
      \"this is a string\"
      |").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(
        value: "\"this is a string\"",
        buffer: "",
        type: Lexeme.Type.STRING
      )
    ]

    expectLexemes(value, expected, checkType: true)
  }

  async test `can lex greater-than-or-equal-to symbol when its not the last lexeme`() {
    let value = Lexer().lex("|
      >= hey
      |").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(
        value: ">=",
        buffer: ""
      ),
      Lexeme(
        value: "hey",
        buffer: " "
      )
    ]

    expectLexemes(value, expected)
  }

  async test `can lex greater-than-or-equal-to symbol`() {
    let value = Lexer().lex("|
      >=
      |").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(
        value: ">=",
        buffer: ""
      )
    ]

    expectLexemes(value, expected)
  }

  async test `can lex less-than-or-equal-to symbol`() {
    let value = Lexer().lex("|
      <=
      |").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(
        value: "<=",
        buffer: ""
      )
    ]

    expectLexemes(value, expected)
  }

  async test `can lex equivalence symbol`() {
    let value = Lexer().lex("|
      ==
      |").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(
        value: "==",
        buffer: ""
      )
    ]

    expectLexemes(value, expected)
  }

  async test `can lex non-equivalence symbol`() {
    let value = Lexer().lex("|
      !=
      |").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(
        value: "!=",
        buffer: ""
      )
    ]

    expectLexemes(value, expected)
  }

  async test `can lex modulo-equals symbol`() {
    let value = Lexer().lex("|
      %=
      |").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(
        value: "%=",
        buffer: ""
      )
    ]

    expectLexemes(value, expected)
  }

  async test `can lex divide-equals symbol`() {
    let value = Lexer().lex("|
      /=
      |").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(
        value: "/=",
        buffer: ""
      )
    ]

    expectLexemes(value, expected)
  }

  async test `can lex multiply-equals symbol`() {
    let value = Lexer().lex("|
      *=
      |").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(
        value: "*=",
        buffer: ""
      )
    ]

    expectLexemes(value, expected)
  }

  async test `can lex plus-equals symbol`() {
    let value = Lexer().lex("|
      +=
      |").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(
        value: "+=",
        buffer: ""
      )
    ]

    expectLexemes(value, expected)
  }

  async test `can lex minus-equals symbol`() {
    let value = Lexer().lex("|
      -=
      |").consumeAll<Lexeme>("data")

    let expected = [
      Lexeme(
        value: "-=",
        buffer: ""
      )
    ]

    expectLexemes(value, expected)
  }

  async test `can lex basic package statement and import statement with location info`() {
    let value = Lexer().lex("|
      package flat/lexer

      import flat/lexer/Lexer
      |").consumeAll<Lexeme>("data")

    let Lexeme[] expected = [
      Lexeme(
        value: "package",
        buffer: "",
        location: Lexeme.Location(
          lineNumber: 1,
          column: 1
        )
      ),
      Lexeme(
        value: "flat",
        buffer: " ",
        location: Lexeme.Location(
          lineNumber: 1,
          column: 9
        )
      ),
      Lexeme(
        value: "lexer",
        buffer: "/",
        location: Lexeme.Location(
          lineNumber: 1,
          column: 14
        )
      ),
      Lexeme(
        value: "",
        buffer: "\n",
        location: Lexeme.Location(
          lineNumber: 2,
          column: 1
        )
      ),
      Lexeme(
        value: "import",
        buffer: "\n",
        location: Lexeme.Location(
          lineNumber: 3,
          column: 1
        )
      ),
      Lexeme(
        value: "flat",
        buffer: " ",
        location: Lexeme.Location(
          lineNumber: 3,
          column: 8
        )
      ),
      Lexeme(
        value: "lexer",
        buffer: "/",
        location: Lexeme.Location(
          lineNumber: 3,
          column: 13
        )
      ),
      Lexeme(
        value: "Lexer",
        buffer: "/",
        location: Lexeme.Location(
          lineNumber: 3,
          column: 19
        )
      )
    ]

    expectLexemes(value, expected, checkLocation: true)
  }

  async test `can lex function call`() {
    let value = Lexer().lex("|
      parse(ParseRequest(sourceCode: test), value)
      |").consumeAll<Lexeme>("data")

    let Lexeme[] expected = [
      Lexeme(value: "parse", buffer: ""),
      Lexeme(value: "ParseRequest", buffer: "("),
      Lexeme(value: "sourceCode", buffer: "("),
      Lexeme(value: "", buffer: ":"),
      Lexeme(value: "test", buffer: " "),
      Lexeme(value: ",", buffer: ")"),
      Lexeme(value: "value", buffer: " "),
      Lexeme(value: "", buffer: ")")
    ]

    expectLexemes(value, expected)
  }
}
